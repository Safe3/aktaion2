#author:azadeh
import re
import entropy as en
import pandas as pd

class microBehaviors:

    # Define a class method for matching base64 strings
    def isBase64(s):
        # check that the string has no remainder in %4, check that it only contains valid characters
        return re.match('^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$', s)

    # Define a class method for matching url encoded strings
    def isUrlEncoded(s):
        # check if the string contains 1/3 or more % characters
        percentCount = 0
        try:
            for c in s:
                if c == '%':
                    percentCount = percentCount +1

            if (percentCount/len(s)) >= (1/3):
                return(True)
            else:
                return(False)
        except(ZeroDivisionError):
            # Catch all exceptions, specifically division by 0 from empty strings
            return(False)

    def max_path_length(inList):
        """return the max path length of all URIs in list"""
        # Declare local var that will store the max path length
        maxLength = 0

        # Count the depth of the file structure for each uri in inList
        for uri in inList:

            # Check the current uri path length against the running length
            if uri.count('/') > maxLength :
                maxLength = uri.count('/')

        return(maxLength)

    def min_path_length(inList):
        """return the min path length of all URIs"""

        # Declare local var that will store the min path length
        minLength = inList[0].count('/')

        # Count the depth of the file structure for each uri in inList
        for uri in inList:

            # Check the current uri path length against the running length
            if uri.count('/') < minLength:
                minLength = uri.count('/')

        return (minLength)

    def max_length(inList):
        """Max length of all URIs in list"""
        maxLength = len(inList[0])

        for uri in inList:
            if len(uri) > maxLength:
                maxLength = len(uri)

        return(maxLength)

    def min_length(inList):
        """Min length of all URIs in list"""
        minLength = len(inList[0])

        for uri in inList:
            if len(uri) < minLength:
                minLength = len(uri)

        return(minLength)

    def max_entropy(inList):
        """ returns the maximum shannon entropy of URIs in the list"""
        try:
            maxEntropy = en.shannon_entropy(inList[0])
        except(IndexError):
            maxEntropy = en.shannon_entropy(inList)

        for uri in inList:
            if maxEntropy <  en.shannon_entropy(uri):
                maxEntropy = en.shannon_entropy(uri)

        return(maxEntropy)

    def min_entropy(inList):
        """ returns the minimum shannon entropy of URIs in the list"""

        minEntropy = en.shannon_entropy(inList[0])

        for uri in inList:
            if minEntropy > en.shannon_entropy(uri):
                minEntropy = en.shannon_entropy(uri)

        return(minEntropy)

    def base_64_match(inList):
        """return the number of URI in inList that could be a base64 encoded string"""

        count = 0

        for uri in inList:
            if microBehaviors.isBase64(uri):
                count = count+1

        return(count)

    def percent_encoding_match(inList):
        """Number of URIs with large number of % encoded strings"""
        count = 0
        for uri in inList:
            if microBehaviors.isUrlEncoded(uri):
                count = count +1

        return(count)

    def uri_distinct(inList):
        """Number of URI's that are unique"""
        # Instantiate the unique strings counter
        count = len(inList)

        # Recursively check for the head of the list in the rest of the list
        while len(inList) > 0:

            # If the head of the list matches, decrement the unique strins counter
            if inList[0] in inList[1:]:
                count = count - 1
            del inList[0]

        return(count)

    def behaviorVector(inList):
        """define a dictionary of learning features: uriMaxPathDepth, uriMinPathDepth, uriMaxLength, uriMinLength, uriDistinct,
        uriMaxEntropy, uriMinEntropy"""
        # Dirty work around for IndexError anomaly generated when calling entropy inside  the dictionary key/value declaration below
        mxEntropy = microBehaviors.max_entropy(inList)
        mnEntropy = microBehaviors.min_entropy(inList)
        behaviorVector = {'uriMaxPathDepth': microBehaviors.max_path_length(inList),
              'uriMinPathDepth': microBehaviors.min_path_length(inList),
              'uriMaxLength':microBehaviors.max_length(inList),
              'uriMinLength':microBehaviors.min_length(inList),
              'uriDistinct':microBehaviors.uri_distinct(inList),
              'uriMaxEntropy':mxEntropy,
              'uriMinEntropy':mnEntropy}
        return(behaviorVector)

class exploitationTimeBehaviors:
    """List of time-delta features, expects a dataFrame of 5 time-ordered rows"""

    # Group of max time intervals
    def max_time_interval_A(inFrame):
        """max_time_interval_A, Difference in timestamp between event 0 and event 1"""
        #cast first 2 rows into datetime objects
        d0, d1  = inFrame.get_value(0,'epochTime').to_pydatetime(), inFrame.get_value(1,'epochTime').to_pydatetime()

        #return difference as two date-time objects as seconds.
        ##Note that this counts days as well and will lose accuracy only after 270 years.
        return(pd.to_timedelta(d1-d0).total_seconds())

    def max_time_interval_B(inFrame):
        """max_time_interval_A, Difference in timestamp between event 1 and event 2"""
        #cast first 2 rows into datetime objects
        d0, d1  = inFrame.get_value(1,'epochTime').to_pydatetime(), inFrame.get_value(2,'epochTime').to_pydatetime()

        return(pd.to_timedelta(d1-d0).total_seconds())

    def max_time_interval_C(inFrame):
        """max_time_interval_A, Difference in timestamp between event 2 and event 3"""
        #cast first 2 rows into datetime objects
        d0, d1  = inFrame.get_value(2,'epochTime').to_pydatetime(), inFrame.get_value(3,'epochTime').to_pydatetime()

        return(pd.to_timedelta(d1-d0).total_seconds())

    def max_time_interval_D(inFrame):
        """max_time_interval_A, Difference in timestamp between event 3 and event 4"""
        #cast first 2 rows into datetime objects
        d0, d1  = inFrame.get_value(3,'epochTime').to_pydatetime(), inFrame.get_value(4,'epochTime').to_pydatetime()

        return(pd.to_timedelta(d1-d0).total_seconds())


    # Group of min time intervals (or difference of time stamps with list sorted in reverse
    def min_time_interval_A(inFrame):
        """min_time_interval_A, Difference in timestamp between event 4 and event 3"""
        #cast first 2 rows into datetime objects
        d0, d1  = inFrame.get_value(4,'epochTime').to_pydatetime(), inFrame.get_value(3,'epochTime').to_pydatetime()

        return(pd.to_timedelta(d1-d0).total_seconds())

    def min_time_interval_B(inFrame):
        """min_time_interval_B, Difference in timestamp between event 3 and event 2"""
        #cast first 2 rows into datetime objects
        d0, d1  = inFrame.get_value(3,'epochTime').to_pydatetime(), inFrame.get_value(2,'epochTime').to_pydatetime()

        return(pd.to_timedelta(d1-d0).total_seconds())

    def min_time_interval_C(inFrame):
        """min_time_interval_C, Difference in timestamp between event 2 and event 1"""
        #cast first 2 rows into datetime objects
        d0, d1  = inFrame.get_value(2,'epochTime').to_pydatetime(), inFrame.get_value(1,'epochTime').to_pydatetime()

        return(pd.to_timedelta(d1-d0).total_seconds())

    def min_time_interval_D(inFrame):
        """min_time_interval_D, Difference in timestamp between event 1 and event 0"""
        #cast first 2 rows into datetime objects
        d0, d1  = inFrame.get_value(1,'epochTime').to_pydatetime(), inFrame.get_value(0,'epochTime').to_pydatetime()

        return(pd.to_timedelta(d1-d0).total_seconds())

    def interval_length(inFrame):
        """Time Length in Window, returns window time delta, difference of last and first time stamps"""

        d0, d1  = inFrame.get_value(0,'epochTime').to_pydatetime(), inFrame.get_value(4,'epochTime').to_pydatetime()

        return(pd.to_timedelta(d1-d0).total_seconds())

    def get_max_deltas(inFrame):
        """Get a list containing the max deltas info"""
        maxDeltasList = [exploitationTimeBehaviors.max_time_interval_A(inFrame),
                     exploitationTimeBehaviors.max_time_interval_B(inFrame),
                     exploitationTimeBehaviors.max_time_interval_C(inFrame),
                     exploitationTimeBehaviors.max_time_interval_D(inFrame)]
        return(maxDeltasList)

    def get_min_deltas(inFrame):
        """Get a list containing the min deltas info"""
        minDeltasList = [exploitationTimeBehaviors.min_time_interval_A(inFrame),
                     exploitationTimeBehaviors.min_time_interval_B(inFrame),
                     exploitationTimeBehaviors.min_time_interval_C(inFrame),
                     exploitationTimeBehaviors.min_time_interval_D(inFrame)]
        return(minDeltasList)

    # Group of time-delta ratio counters
    def ratio_of_deltas_A(inFrame):
        """(Count of time-deltas < 1 second)/(window size)"""
        counter = 0

        for i in exploitationTimeBehaviors.get_max_deltas(inFrame):
            if i < 1:
                counter = counter +1
        for i in exploitationTimeBehaviors.get_min_deltas(inFrame):
            if i < 1:
                counter = counter + 1

        return(counter/exploitationTimeBehaviors.interval_length(inFrame))

    def ratio_of_deltas_B(inFrame):
        """(Count of time-deltas < 5 second)/(window size)"""
        counter = 0

        for i in exploitationTimeBehaviors.get_max_deltas(inFrame):
            if i < 5:
                counter = counter +1
        for i in exploitationTimeBehaviors.get_min_deltas(inFrame):
            if i < 5:
                counter = counter + 1

        return(counter/exploitationTimeBehaviors.interval_length(inFrame))

    def ratio_of_deltas_C(inFrame):
        """(Count of time-deltas < 10 second)/(window size)"""
        counter = 0

        for i in exploitationTimeBehaviors.get_max_deltas(inFrame):
            if i < 10:
                counter = counter + 1
        for i in exploitationTimeBehaviors.get_min_deltas(inFrame):
            if i < 10:
                counter = counter + 1

        return(counter/exploitationTimeBehaviors.interval_length(inFrame))

    def ratio_of_deltas_D(inFrame):
        """(Count of time-deltas < 20 second)/(window size)"""
        counter = 0

        for i in exploitationTimeBehaviors.get_max_deltas(inFrame):
            if i < 20:
                counter = counter + 1
        for i in exploitationTimeBehaviors.get_min_deltas(inFrame):
            if i < 20:
                counter = counter + 1

        return(counter/exploitationTimeBehaviors.interval_length(inFrame))

    def ratio_of_deltas_E(inFrame):
        """(Count of time-deltas >= 100 second)/(window size)"""
        counter = 0

        for i in exploitationTimeBehaviors.get_max_deltas(inFrame):
            if i >= 100:
                counter = counter + 1
        for i in exploitationTimeBehaviors.get_min_deltas(inFrame):
            if i >= 100:
                counter = counter + 1

        return(counter/exploitationTimeBehaviors.interval_length(inFrame))


    #define the behavior Vector
    def behavior_vector(self):
        """Give a dataFrame with 5 time-ordered rows:
            return the Time intervals between each row, and the
            time interval between the first and last row """
        behaviorVector = [exploitationTimeBehaviors.max_time_interval_A(self),
                          exploitationTimeBehaviors.max_time_interval_B(self),
                          exploitationTimeBehaviors.max_time_interval_C(self),
                          exploitationTimeBehaviors.max_time_interval_D(self),
                          exploitationTimeBehaviors.min_time_interval_A(self),
                          exploitationTimeBehaviors.min_time_interval_B(self),
                          exploitationTimeBehaviors.min_time_interval_C(self),
                          exploitationTimeBehaviors.min_time_interval_D(self),
                          exploitationTimeBehaviors.interval_length(self)]
        return(behaviorVector)
